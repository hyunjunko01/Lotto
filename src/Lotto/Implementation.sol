// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {ILottoFactory} from "./Interface/ILottoFactory.sol";
import {Initializable} from "@openzeppelin/contracts/proxy/utils/Initializable.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title LottoImplementation
 * @dev Contract that is cloned by the factory and performs the actual lotto logic
 * @author Tyler Ko
 */
contract LottoImplementation is Initializable, ReentrancyGuard {
    // --- error ---
    error Lotto__IsNotOpen();
    error Lotto__IsNotCalculating();
    error Lotto__IsNotClosed();
    error Lotto__InsufficientEntryFee();
    error Lotto__NotAllPlayersJoined();
    error Lotto__OnlyFactoryCanFulfill();
    error Lotto__TransferFailed();
    error Lotto__YouAreNotWinner();

    enum LottoState {
        OPEN,
        CALCULATING,
        CLOSED
    }

    // --- state variables (stored in proxy's storage) ---
    uint256 public entryFee;
    uint256 public maxPlayers;
    address[] public players;
    address public winner;
    address public factory; // address of the factory that will provide randomness
    LottoState public lottoState;

    // --- events ---
    event PlayerJoined(address indexed player, uint256 playerCount);
    event WinnerRequested();
    event WinnerPicked(address indexed winner, uint256 prize);

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers(); // Prevent the implementation contract from being initialized directly
    }

    /**
     * @notice Initialization function replacing the constructor
     * @dev Called by the factory immediately after Clones.clone()
     */
    function initialize(uint256 _entryFee, uint256 _maxPlayers, address _factory) external initializer {
        entryFee = _entryFee;
        maxPlayers = _maxPlayers;
        factory = _factory;
        lottoState = LottoState.OPEN;
    }

    /**
     * @notice Function for joining the lotto
     */
    function joinLotto() external payable {
        if (lottoState != LottoState.OPEN) revert Lotto__IsNotOpen();
        if (msg.value < entryFee) revert Lotto__InsufficientEntryFee();

        players.push(msg.sender);

        emit PlayerJoined(msg.sender, players.length);

        // Automatically change state to CALCULATING when max players reached
        if (players.length >= maxPlayers) {
            lottoState = LottoState.CALCULATING;
        }
    }

    /**
     * @notice Trigger randomness request for selecting the winner
     */
    function requestWinner() external {
        if (lottoState != LottoState.CALCULATING) revert Lotto__IsNotCalculating();
        if (players.length < maxPlayers) revert Lotto__NotAllPlayersJoined();

        // Request VRF randomness from the factory
        ILottoFactory(factory).requestWinnerRandomness();

        emit WinnerRequested();
    }

    /**
     * @notice Callback function called by the factory after receiving randomness
     * @param _randomness Random number generated by Chainlink VRF
     */
    function finalizeWinner(uint256 _randomness) external {
        // Security: Only the factory contract can call this function
        if (msg.sender != factory) revert Lotto__OnlyFactoryCanFulfill();
        if (lottoState != LottoState.CALCULATING) revert Lotto__IsNotCalculating();

        // Winner selection logic (Modulo operation)
        // $WinnerIndex = randomness \pmod{maxPlayers}$
        uint256 winnerIndex = _randomness % maxPlayers;
        winner = players[winnerIndex];

        lottoState = LottoState.CLOSED;

        uint256 prize = address(this).balance;
        emit WinnerPicked(winner, prize);
    }

    /**
     * @notice Function for the winner to withdraw their rewards
     */
    function withdrawRewards() external nonReentrant {
        if (lottoState != LottoState.CLOSED) revert Lotto__IsNotClosed();
        if (msg.sender != winner) revert Lotto__YouAreNotWinner(); // Additional logic can be added to ensure only the winner can call this
        uint256 amount = address(this).balance;
        (bool success,) = payable(winner).call{value: amount}("");
        if (!success) revert Lotto__TransferFailed();
    }

    // --- Getter functions ---
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

