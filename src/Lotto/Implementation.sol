// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {ILottoFactory} from "./Interface/ILottoFactory.sol";
import {Initializable} from "@openzeppelin/contracts/proxy/utils/Initializable.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title Lotto Implementation (logic contract)
 * @author HyunJun Ko
 * @notice This contract contains the core logic for the Lotto game.
 * @dev This contract is designed to be used with the EIP-1167 minimal proxy pattern.
 * @dev Each Lotto instance by factory is a proxy that delegates calls to this implementation contract.
 */
contract LottoImplementation is Initializable, ReentrancyGuard {
    // --- error ---
    error Lotto__IsNotOpen();
    error Lotto__IsNotCalculating();
    error Lotto__IsNotClosed();
    error Lotto__InsufficientEntryFee();
    error Lotto__NotAllPlayersJoined();
    error Lotto__LottoIsFull();
    error Lotto__OnlyFactoryCanFulfill();
    error Lotto__TransferFailed();
    error Lotto__RefundFailed();
    error Lotto__YouAreNotWinner();

    // --- enum ---
    enum LottoState {
        OPEN,
        CALCULATING,
        CLOSED
    }

    // --- state variables (stored in proxy's storage) ---
    uint256 public entryFee;
    uint256 public maxPlayers;
    address[] public players;
    address public winner;
    address public factory; // address of the factory that will provide randomness
    LottoState public lottoState;

    // --- events ---
    event PlayerJoined(address indexed player, uint256 playerCount);
    event WinnerRequested();
    event WinnerPicked(address indexed winner, uint256 prize);
    event PrizeWithdrawn(address indexed winner, uint256 amount);

    // --- constructor ---
    constructor() {
        _disableInitializers(); // Prevent the implementation contract from being initialized directly
    }

    // --- external functions ---
    /**
     * @notice Initialization function replacing the constructor
     * @dev It only affects the storage of the calling subject.
     * @dev So each lotto instance gets its own storage.
     * @dev Called by the factory immediately after Clones.clone()
     */
    function initialize(uint256 _entryFee, uint256 _maxPlayers, address _factory) external initializer {
        entryFee = _entryFee;
        maxPlayers = _maxPlayers;
        factory = _factory;
        lottoState = LottoState.OPEN;
    }

    /**
     * @notice Function for joining the lotto
     * @dev Players can join by sending the entry fee. The lotto automatically transitions to CALCULATING state when max players are reached.
     * @dev If a player sends more than the entry fee, the excess amount will be refunded.
     */
    function joinLotto() external payable {
        if (lottoState != LottoState.OPEN) revert Lotto__IsNotOpen();
        if (msg.value < entryFee) revert Lotto__InsufficientEntryFee();
        if (players.length >= maxPlayers) revert Lotto__LottoIsFull();
        if (msg.value > entryFee) {
            (bool success,) = payable(msg.sender).call{value: msg.value - entryFee}("");
            if (!success) revert Lotto__RefundFailed();
        }

        players.push(msg.sender);

        emit PlayerJoined(msg.sender, players.length);

        // Automatically change state to CALCULATING when max players reached
        if (players.length == maxPlayers) {
            lottoState = LottoState.CALCULATING;
        }
    }

    /**
     * @notice Trigger randomness request for selecting the winner
     * @dev The actual randomness request is made to the factory contract, which then interacts with Chainlink VRF.
     * @dev If we don't interact with factory, we should adminster chainlick VRF directly in this contract, which would make the logic contract more complex.
     */
    function requestWinner() external {
        if (lottoState != LottoState.CALCULATING) revert Lotto__IsNotCalculating();
        if (players.length < maxPlayers) revert Lotto__NotAllPlayersJoined();

        // Request VRF randomness from the factory
        ILottoFactory(factory).requestWinnerRandomness();

        emit WinnerRequested();
    }

    /**
     * @notice Callback function called by the factory after receiving randomness
     * @dev This function is called by the factory contract after it receives the random number from Chainlink VRF.
     * @param _randomness Random number generated by Chainlink VRF
     */
    function finalizeWinner(uint256 _randomness) external {
        // Security: Only the factory contract can call this function
        if (msg.sender != factory) revert Lotto__OnlyFactoryCanFulfill();
        if (lottoState != LottoState.CALCULATING) revert Lotto__IsNotCalculating();

        // Winner selection logic (Modulo operation)
        // $WinnerIndex = randomness \pmod{maxPlayers}$
        uint256 winnerIndex = _randomness % maxPlayers;
        winner = players[winnerIndex];

        lottoState = LottoState.CLOSED;

        uint256 prize = address(this).balance;
        emit WinnerPicked(winner, prize);
    }

    /**
     * @notice Function for the winner to withdraw their Prize
     */
    function withdrawPrize() external nonReentrant {
        if (lottoState != LottoState.CLOSED) revert Lotto__IsNotClosed();
        if (msg.sender != winner) revert Lotto__YouAreNotWinner(); // Additional logic can be added to ensure only the winner can call this
        uint256 amount = address(this).balance;
        (bool success,) = payable(winner).call{value: amount}("");
        if (!success) revert Lotto__TransferFailed();

        emit PrizeWithdrawn(winner, amount);
    }

    // --- Getter functions ---
    function getLottoBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

